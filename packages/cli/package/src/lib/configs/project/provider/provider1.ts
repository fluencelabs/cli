/**
 * Fluence CLI
 * Copyright (C) 2024 Fluence DAO
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import type { JSONSchemaType } from "ajv";
import isUndefined from "lodash-es/isUndefined.js";
import mapValues from "lodash-es/mapValues.js";
import omitBy from "lodash-es/omitBy.js";

import {
  COMPUTE_UNIT_MEMORY_STR,
  DEFAULT_AQUAVM_POOL_SIZE,
  HTTP_PORT_START,
  TCP_PORT_START,
  WEB_SOCKET_PORT_START,
  DEFAULT_NUMBER_OF_COMPUTE_UNITS_ON_NOX,
} from "../../../const.js";
import { boolToStr, numToStr } from "../../../helpers/typesafeStringify.js";
import type { ConfigOptions } from "../../initConfigNewTypes.js";

import {
  type Config as PrevConfig,
  providerNameSchema,
  type Effector,
  effectorSchema,
  type CapacityCommitments,
  capacityCommitmentsSchema,
  type Offers,
  offersSchema,
  type NoxConfigYAML as PrevNoxConfigYAML,
  type ChainConfig as PrevChainConfig,
  type ComputePeers as PrevComputePeers,
} from "./provider0.js";

export type NoxConfigYAML = {
  tcpPort?: number;
  websocketPort?: number;
  httpPort?: number;
  aquavmPoolSize?: number;
  systemServices?: {
    enable?: Array<string>;
    aquaIpfs?: {
      externalApiMultiaddr?: string;
      localApiMultiaddr?: string;
      ipfsBinaryPath?: string;
    };
    decider?: {
      deciderPeriodSec?: number;
      workerPeriodSec?: number;
      workerIpfsMultiaddr?: string;
      networkApiEndpoint?: string;
      networkId?: number;
      startBlock?: string;
      matcherAddress?: string;
      walletKey?: string;
    };
  };
  effectors?: Record<string, Effector>;
  rawConfig?: string;
  chain?: {
    httpEndpoint?: string;
    networkId?: number;
    wsEndpoint?: string;
    dealSyncStartBlock?: string;
    marketContract?: string;
    ccContract?: string;
    coreContract?: string;
    diamondContract?: string;
    walletPrivateKey?: string;
    defaultBaseFee?: number;
    defaultPriorityFee?: number;
  };
  ccp?: {
    ccpEndpoint?: string;
    proofPollPeriod?: string;
  };
  ipfs?: {
    externalApiMultiaddr?: string;
    localApiMultiaddr?: string;
    ipfsBinaryPath?: string;
  };
  cpusRange?: string;
  systemCpuCount?: number;
  listenIp?: string;
  externalMultiaddresses?: Array<string>;
  metrics?: {
    enabled?: boolean;
    timerResolution?: string;
    tokioMetricsEnabled?: boolean;
    tokioDetailedMetricsEnabled?: boolean;
  };
  bootstrapNodes?: Array<string>;
  vm?: {
    libvirtUri?: string;
    allowGpu?: boolean;
    network: {
      bridgeName?: string;
      publicIp: string;
      vmIp?: string;
      portRange?: {
        start?: number;
        end?: number;
      };
      hostSshPort?: number;
      vmSshPort?: number;
    };
  };
};

export const DEFAULT_TIMER_RESOLUTION = "1 minute";
export const DEFAULT_PROOF_POLL_PERIOD = "60 seconds";
export const DEFAULT_IPFS_BINARY_PATH = "/usr/bin/ipfs";

export const noxConfigYAMLSchema = {
  type: "object",
  description:
    "Configuration to pass to the nox compute peer. Config.toml files are generated from this config",
  properties: {
    tcpPort: {
      nullable: true,
      type: "integer",
      description: `Both host and container TCP port to use. Default: ${numToStr(
        TCP_PORT_START,
      )} (on local network ports will be generated by default)`,
    },
    websocketPort: {
      nullable: true,
      type: "integer",
      description: `Both host and container WebSocket port to use. Default: ${numToStr(
        WEB_SOCKET_PORT_START,
      )} (on local network ports will be generated by default)`,
    },
    httpPort: {
      nullable: true,
      type: "integer",
      description: `Both host and container HTTP port to use. Default: ${numToStr(
        HTTP_PORT_START,
      )} (on local network ports will be generated by default)`,
    },
    aquavmPoolSize: {
      nullable: true,
      type: "integer",
      description: `Number of aquavm instances to run. Default: ${numToStr(
        DEFAULT_AQUAVM_POOL_SIZE,
      )}`,
    },
    systemServices: {
      nullable: true,
      type: "object",
      description:
        "System services to run by default. aquaIpfs and decider are enabled by default",
      additionalProperties: false,
      properties: {
        enable: {
          nullable: true,
          type: "array",
          items: { type: "string" },
          description: `List of system services to enable`,
        },
        aquaIpfs: {
          type: "object",
          description: "Aqua IPFS service configuration",
          additionalProperties: false,
          nullable: true,
          properties: {
            externalApiMultiaddr: {
              nullable: true,
              type: "string",
              description: `Multiaddress of external IPFS API`,
            },
            localApiMultiaddr: {
              nullable: true,
              type: "string",
              description: `Multiaddress of local IPFS API`,
            },
            ipfsBinaryPath: {
              nullable: true,
              type: "string",
              description: `Path to the IPFS binary. Default: ${DEFAULT_IPFS_BINARY_PATH}`,
            },
          },
          required: [],
        },
        decider: {
          type: "object",
          description: "Decider service configuration",
          additionalProperties: false,
          nullable: true,
          properties: {
            deciderPeriodSec: {
              nullable: true,
              type: "integer",
              description: `Decider period in seconds`,
            },
            workerPeriodSec: {
              nullable: true,
              type: "integer",
              description: `Worker period in seconds`,
            },
            workerIpfsMultiaddr: {
              nullable: true,
              type: "string",
              description: `Multiaddress of worker IPFS node`,
            },
            networkApiEndpoint: {
              nullable: true,
              type: "string",
              description: `Network API endpoint (deprecated)`,
            },
            networkId: {
              nullable: true,
              type: "integer",
              description: `Network ID (deprecated)`,
            },
            startBlock: {
              nullable: true,
              type: "string",
              description: `Start block (deprecated)`,
            },
            matcherAddress: {
              nullable: true,
              type: "string",
              description: `Matcher address (deprecated)`,
            },
            walletKey: {
              nullable: true,
              type: "string",
              description: `Wallet key (deprecated)`,
            },
          },
          required: [],
        },
      },
      required: [],
    },
    effectors: {
      nullable: true,
      type: "object",
      description: "Effectors to allow on the nox",
      additionalProperties: effectorSchema,
      properties: {
        effectorName: effectorSchema,
      },
      required: [],
    },
    chain: {
      nullable: true,
      type: "object",
      description: "Chain config",
      additionalProperties: false,
      properties: {
        dealSyncStartBlock: {
          nullable: true,
          type: "string",
          description: `Start block (deprecated)`,
        },
        wsEndpoint: {
          nullable: true,
          type: "string",
          description: `WebSocket endpoint of the chain`,
        },
        httpEndpoint: {
          nullable: true,
          type: "string",
          description: `HTTP endpoint of the chain`,
        },
        coreContract: {
          nullable: true,
          type: "string",
          description: `Core contract address (deprecated)`,
        },
        ccContract: {
          nullable: true,
          type: "string",
          description: `Capacity commitment contract address (deprecated)`,
        },
        marketContract: {
          nullable: true,
          type: "string",
          description: `Market contract address (deprecated)`,
        },
        diamondContract: {
          nullable: true,
          type: "string",
          description: `Diamond contract address`,
        },
        networkId: {
          nullable: true,
          type: "integer",
          description: `Network ID`,
        },
        walletPrivateKey: {
          nullable: true,
          type: "string",
          description: `Nox wallet private key. Is generated by default`,
        },
        defaultBaseFee: {
          nullable: true,
          type: "number",
          description: `Default base fee`,
        },
        defaultPriorityFee: {
          nullable: true,
          type: "number",
          description: `Default priority fee`,
        },
      },
      required: [],
    },
    ccp: {
      nullable: true,
      type: "object",
      description: "For advanced users. CCP config",
      additionalProperties: false,
      properties: {
        ccpEndpoint: {
          nullable: true,
          type: "string",
          description: `CCP endpoint. Default comes from top-level ccp config: http://{ccp.rpcEndpoint.host}:{ccp.rpcEndpoint.port}`,
        },
        proofPollPeriod: {
          nullable: true,
          type: "string",
          description: `Proof poll period. Default: ${DEFAULT_PROOF_POLL_PERIOD}`,
          default: DEFAULT_PROOF_POLL_PERIOD,
        },
      },
      required: [],
    },
    ipfs: {
      nullable: true,
      type: "object",
      description: "IPFS config",
      additionalProperties: false,
      properties: {
        externalApiMultiaddr: {
          nullable: true,
          type: "string",
          description: `Multiaddress of external IPFS API`,
        },
        localApiMultiaddr: {
          nullable: true,
          type: "string",
          description: `Multiaddress of local IPFS API`,
        },
        ipfsBinaryPath: {
          nullable: true,
          type: "string",
          description: `Path to the IPFS binary. Default: ${DEFAULT_IPFS_BINARY_PATH}`,
        },
      },
      required: [],
    },
    cpusRange: {
      nullable: true,
      type: "string",
      description: `Range of CPU cores to use. Default: 1-32`,
    },
    systemCpuCount: {
      nullable: true,
      type: "integer",
      minimum: 1,
      description: `Number of CPU cores to allocate for the Nox itself. Default: 1`,
    },
    listenIp: {
      nullable: true,
      type: "string",
      format: "ipv4",
      description: `IP to listen on`,
    },
    externalMultiaddresses: {
      nullable: true,
      type: "array",
      items: { type: "string" },
      description: `List of external multiaddresses`,
    },
    metrics: {
      nullable: true,
      type: "object",
      description: "Metrics configuration",
      additionalProperties: false,
      properties: {
        enabled: {
          nullable: true,
          type: "boolean",
          description: `Metrics enabled. Default: true`,
          default: true,
        },
        timerResolution: {
          nullable: true,
          type: "string",
          description: `Timer resolution. Default: ${DEFAULT_TIMER_RESOLUTION}`,
          default: DEFAULT_TIMER_RESOLUTION,
        },
        tokioMetricsEnabled: {
          nullable: true,
          type: "boolean",
          description: `Tokio metrics enabled. Default: true`,
          default: true,
        },
        tokioDetailedMetricsEnabled: {
          nullable: true,
          type: "boolean",
          description: `Tokio detailed metrics enabled`,
        },
      },
      required: [],
    },
    bootstrapNodes: {
      nullable: true,
      type: "array",
      items: { type: "string" },
      description: `List of bootstrap nodes. Default: all addresses for the selected env`,
    },
    rawConfig: {
      nullable: true,
      type: "string",
      description: `Raw TOML config string to parse and merge with the rest of the config. Has the highest priority`,
    },
    vm: {
      type: "object",
      description: "VM Configuration",
      additionalProperties: false,
      nullable: true,
      required: ["network"],
      properties: {
        libvirtUri: {
          nullable: true,
          type: "string",
          description: `QEMU Socket`,
        },
        allowGpu: {
          nullable: true,
          type: "boolean",
          description: `Whether to add info about GPUs to VM's XML`,
        },
        network: {
          type: "object",
          description: "VM Network Configuration",
          additionalProperties: false,
          nullable: false,
          required: ["publicIp"],
          properties: {
            bridgeName: {
              nullable: true,
              type: "string",
              description: `Name of the network bridge device`,
            },
            publicIp: {
              nullable: false,
              type: "string",
              format: "ipv4",
              description: `Public IP address to assign the VM. Must be publicly accessible.`,
            },
            vmIp: {
              nullable: true,
              type: "string",
              format: "ipv4",
              description: `Internal IP address to assign the VM`,
            },
            portRange: {
              type: "object",
              description: "iptables-mapped port range from Host to VM",
              additionalProperties: false,
              nullable: true,
              required: [],
              properties: {
                start: {
                  nullable: true,
                  type: "integer",
                  description: `Start of the iptables-mapped port range from Host to VM`,
                },
                end: {
                  nullable: true,
                  type: "integer",
                  description: `End of the iptables-mapped port range from Host to VM`,
                },
              },
            },
            hostSshPort: {
              nullable: true,
              type: "integer",
              description: `Host SSH port, default is 922`,
            },
            vmSshPort: {
              nullable: true,
              type: "integer",
              description: `VM SSH port, default is 22`,
            },
          },
        },
      },
    },
  },
  required: [],
  nullable: true,
  additionalProperties: false,
} as const satisfies JSONSchemaType<NoxConfigYAML>;

export type CCPConfigYAML = {
  rpcEndpoint?: {
    host?: string;
    port?: number;
    utilityThreadIds?: Array<number>;
  };
  prometheusEndpoint?: {
    host?: string;
    port?: number;
  };
  logs?: {
    reportHashrate?: boolean;
    logLevel?: string;
  };
  state?: {
    path?: string;
  };
  rawConfig?: string;
};

export const DEFAULT_RPC_ENDPOINT_HOST = "0.0.0.0";
export const DEFAULT_RPC_ENDPOINT_PORT = 9389;
export const DEFAULT_PROMETHEUS_ENDPOINT_HOST = "0.0.0.0";
export const DEFAULT_PROMETHEUS_ENDPOINT_PORT = 9384;
export const DEFAULT_REPORT_HASHRATE = false;
export const DEFAULT_LOG_LEVEL = "debug";
const DEFAULT_STATE_PATH = "./state";

export const ccpConfigYAMLSchema = {
  type: "object",
  description: "Configuration to pass to the Capacity Commitment Prover",
  properties: {
    rpcEndpoint: {
      type: "object",
      description: "RPC endpoint configuration",
      additionalProperties: false,
      nullable: true,
      properties: {
        host: {
          nullable: true,
          type: "string",
          description: `RPC host. Default: ${DEFAULT_RPC_ENDPOINT_HOST}`,
          default: DEFAULT_RPC_ENDPOINT_HOST,
        },
        port: {
          nullable: true,
          type: "integer",
          description: `RPC port. Default: ${numToStr(
            DEFAULT_RPC_ENDPOINT_PORT,
          )}`,
          default: DEFAULT_RPC_ENDPOINT_PORT,
        },
        utilityThreadIds: {
          nullable: true,
          type: "array",
          items: { type: "integer" },
          description: `Utility thread IDs`,
        },
      },
      required: [],
    },
    prometheusEndpoint: {
      type: "object",
      description: "Prometheus endpoint configuration",
      additionalProperties: false,
      nullable: true,
      properties: {
        host: {
          nullable: true,
          type: "string",
          description: `Prometheus host. Default: ${DEFAULT_PROMETHEUS_ENDPOINT_HOST}`,
          default: DEFAULT_PROMETHEUS_ENDPOINT_HOST,
        },
        port: {
          nullable: true,
          type: "integer",
          description: `Prometheus port. Default: ${numToStr(
            DEFAULT_PROMETHEUS_ENDPOINT_PORT,
          )}`,
          default: DEFAULT_PROMETHEUS_ENDPOINT_PORT,
        },
      },
      required: [],
    },
    logs: {
      type: "object",
      description: "Logs configuration",
      additionalProperties: false,
      nullable: true,
      properties: {
        reportHashrate: {
          nullable: true,
          type: "boolean",
          description: `Report hashrate. Default: ${boolToStr(
            DEFAULT_REPORT_HASHRATE,
          )}`,
          default: DEFAULT_REPORT_HASHRATE,
        },
        logLevel: {
          nullable: true,
          type: "string",
          description: `Log level. Default: ${DEFAULT_LOG_LEVEL}`,
          default: DEFAULT_LOG_LEVEL,
        },
      },
      required: [],
    },
    state: {
      type: "object",
      description: "State configuration",
      additionalProperties: false,
      nullable: true,
      properties: {
        path: {
          nullable: true,
          type: "string",
          description: `Path to the state file. Default: ${DEFAULT_STATE_PATH}`,
          default: DEFAULT_STATE_PATH,
        },
      },
    },
    rawConfig: {
      nullable: true,
      type: "string",
      description: `Raw TOML config string to parse and merge with the rest of the config. Has the highest priority`,
    },
  },
  required: [],
  nullable: true,
  additionalProperties: false,
} as const satisfies JSONSchemaType<CCPConfigYAML>;

export type ComputePeer = {
  computeUnits: number;
  nox?: NoxConfigYAML;
  ccp?: CCPConfigYAML;
};

const computePeerSchema = {
  type: "object",
  description: "Defines a compute peer",
  additionalProperties: false,
  properties: {
    computeUnits: {
      type: "integer",
      description: `How many compute units should nox have. Default: ${numToStr(
        DEFAULT_NUMBER_OF_COMPUTE_UNITS_ON_NOX,
      )} (each compute unit requires ${COMPUTE_UNIT_MEMORY_STR} of RAM)`,
    },
    nox: noxConfigYAMLSchema,
    ccp: ccpConfigYAMLSchema,
  },
  required: ["computeUnits"],
} as const satisfies JSONSchemaType<ComputePeer>;

export type ComputePeers = Record<string, ComputePeer>;

export const computePeersSchema = {
  description:
    "A map with compute peer names as keys and compute peers as values",
  type: "object",
  additionalProperties: computePeerSchema,
  properties: {
    ComputePeer: computePeerSchema,
  },
  required: [],
} as const satisfies JSONSchemaType<ComputePeers>;

export type Config = {
  providerName: string;
  offers: Offers;
  capacityCommitments: CapacityCommitments;
  nox?: NoxConfigYAML;
  computePeers: ComputePeers;
  ccp?: CCPConfigYAML;
};

export default {
  schema: {
    type: "object",
    additionalProperties: false,
    properties: {
      providerName: providerNameSchema,
      offers: offersSchema,
      capacityCommitments: capacityCommitmentsSchema,
      computePeers: computePeersSchema,
      nox: noxConfigYAMLSchema,
      ccp: ccpConfigYAMLSchema,
    },
    required: ["computePeers", "offers", "providerName", "capacityCommitments"],
  },
  migrate({ nox, computePeers, ...restConfig }) {
    const newConfig: Omit<Config, "computePeers"> = restConfig;

    if (nox !== undefined) {
      newConfig.nox = migrateNoxConfigYAML(nox);
    }

    return { ...newConfig, computePeers: migrateComputePeers(computePeers) };
  },
} satisfies ConfigOptions<PrevConfig, Config>;

function migrateComputePeers(
  computePeers: PrevComputePeers,
): Config["computePeers"] {
  return mapValues(computePeers, ({ nox, ...computePeer }) => {
    return nox === undefined
      ? computePeer
      : { ...computePeer, nox: migrateNoxConfigYAML(nox) };
  });
}

function migrateNoxConfigYAML({ chainConfig, ...restNox }: PrevNoxConfigYAML) {
  return chainConfig === undefined
    ? restNox
    : { ...restNox, chain: migrateChainConfig(chainConfig) };
}

function migrateChainConfig({
  walletKey,
  ...restChainConfig
}: PrevChainConfig) {
  return omitBy(
    { ...restChainConfig, walletPrivateKey: walletKey },
    isUndefined,
  );
}
