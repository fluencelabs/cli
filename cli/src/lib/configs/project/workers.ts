/**
 * Fluence CLI
 * Copyright (C) 2024 Fluence DAO
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import { join } from "path";

import type { JSONSchemaType } from "ajv";
import isEmpty from "lodash-es/isEmpty.js";

import {
  CHAIN_ENV_OLD,
  type ChainENVOld,
  chainEnvOldToNew,
  DEFAULT_PUBLIC_FLUENCE_ENV,
  isChainEnvOld,
} from "../../../common.js";
import { ajv, validationErrorToString } from "../../ajvInstance.js";
import {
  WORKERS_CONFIG_FULL_FILE_NAME,
  TOP_LEVEL_SCHEMA_ID,
  WORKERS_CONFIG_FILE_NAME,
  CLI_NAME,
  DEFAULT_DEPLOYMENT_NAME,
  DEFAULT_WORKER_NAME,
  FLUENCE_ENVS,
  type FluenceEnvOld,
  type FluenceEnv,
} from "../../const.js";
import { getFluenceDir } from "../../paths.js";
import { fluenceEnvOldPrompt } from "../../resolveFluenceEnv.js";
import {
  getReadonlyConfigInitFunction,
  getConfigInitFunction,
  type InitConfigOptions,
  type InitializedConfig,
  type InitializedReadonlyConfig,
  type Migrations,
  type GetDefaultConfig,
} from "../initConfig.js";

type WorkerInfo = {
  timestamp: string;
  definition: string;
};

const workerInfoSchema = {
  type: "object",
  properties: {
    definition: {
      type: "string",
      description:
        "CID of uploaded to IPFS App Definition, which contains the data about everything that you are trying to deploy, including spells, service and module configs and CIDs for service wasms",
    },
    timestamp: {
      type: "string",
      description: "ISO timestamp of the time when the worker was deployed",
    },
  },
  required: ["timestamp", "definition"],
  additionalProperties: false,
} as const satisfies JSONSchemaType<WorkerInfo>;

type DealV1 = WorkerInfo & {
  dealId: string;
  dealIdOriginal: string;
  chainNetworkId: number;
  chainNetwork?: ChainENVOld;
  matched?: boolean;
};

type HostV1 = WorkerInfo & {
  relayId: string;
  dummyDealId: string;
  installation_spells: {
    host_id: string;
    spell_id: string;
    worker_id: string;
  }[];
};

type ConfigV0 = {
  version: 0;
  deals?: Record<string, DealV1>;
  hosts?: Record<string, HostV1>;
};

const hostSchemaV1: JSONSchemaType<HostV1> = {
  ...workerInfoSchema,
  description:
    "Contains data related to your direct deployment. Most importantly, it contains ids in installation_spells property that can be used to resolve workers in aqua",
  properties: {
    ...workerInfoSchema.properties,
    dummyDealId: {
      type: "string",
      description:
        "random string generated by CLI, used in Nox. You can get worker id from it",
    },
    installation_spells: {
      type: "array",
      description: "A list of installation spells",
      items: {
        type: "object",
        properties: {
          host_id: {
            type: "string",
            description:
              "Can be used to access worker in aqua: `on s.workerId via s.hostId`",
          },
          spell_id: {
            type: "string",
            description:
              "id of the installation spell, can be used to e.g. print spell logs",
          },
          worker_id: {
            type: "string",
            description:
              "Can be used to access worker in aqua: `on s.workerId via s.hostId`",
          },
        },
        required: ["host_id", "spell_id", "worker_id"],
        additionalProperties: false,
      },
    },
    relayId: {
      type: "string",
      description: "relay peer id that was used when deploying",
    },
  },
  required: [
    ...workerInfoSchema.required,
    "installation_spells",
    "relayId",
    "dummyDealId",
  ],
} as const;

const dealSchemaV1: JSONSchemaType<DealV1> = {
  ...workerInfoSchema,
  description:
    "Contains data related to your deployment, including, most importantly, deal id, that can be used to resolve workers in aqua",
  properties: {
    ...workerInfoSchema.properties,
    dealId: {
      type: "string",
      description:
        "Lowercased version of dealIdOriginal without 0x prefix. Currently unused. Was previously used to resolve workers in aqua",
    },
    dealIdOriginal: {
      type: "string",
      description:
        "Blockchain transaction id that you get when deploy workers. Can be used in aqua to get worker and host ids. Check out example in the aqua generated in the default template",
    },
    chainNetwork: {
      type: "string",
      enum: CHAIN_ENV_OLD,
      description:
        "DEPRECATED. Blockchain network name that was used when deploying workers",
      nullable: true,
    },
    chainNetworkId: {
      type: "integer",
      description: "Blockchain network id that was used when deploying workers",
    },
    matched: {
      type: "boolean",
      description: "Is deal matched",
      nullable: true,
    },
  },
  required: [
    ...workerInfoSchema.required,
    "dealId",
    "dealIdOriginal",
    "chainNetworkId",
  ],
} as const;

const mapOfDealsSchemaV1 = {
  type: "object",
  description: "A map of created deals",
  additionalProperties: dealSchemaV1,
  properties: {
    Worker_deployed_using_deals: dealSchemaV1,
  },
  required: [],
  nullable: true,
} as const satisfies JSONSchemaType<Record<string, DealV1>>;

const mapOfHostsSchemaV1 = {
  type: "object",
  description: "A map of directly deployed workers",
  additionalProperties: hostSchemaV1,
  properties: {
    Worker_deployed_using_direct_hosting: hostSchemaV1,
  },
  required: [],
  nullable: true,
} as const satisfies JSONSchemaType<Record<string, HostV1>>;

const configSchemaV0: JSONSchemaType<ConfigV0> = {
  type: "object",
  additionalProperties: false,
  properties: {
    version: { type: "integer", const: 0 },
    deals: mapOfDealsSchemaV1,
    hosts: mapOfHostsSchemaV1,
  },
  required: ["version"],
} as const;

type DealsV1 = Partial<Record<FluenceEnvOld, Record<string, DealV1>>>;
type HostsV1 = Partial<Record<FluenceEnvOld, Record<string, HostV1>>>;

type ConfigV1 = {
  version: 1;
  deals?: DealsV1;
  hosts?: HostsV1;
};

const configSchemaV1: JSONSchemaType<ConfigV1> = {
  type: "object",
  additionalProperties: false,
  required: ["version"],
  properties: {
    version: { type: "integer", const: 1, description: "Config version" },
    deals: {
      type: "object",
      description:
        "Info about deals created when deploying workers that is stored by environment that you deployed to",
      additionalProperties: false,
      nullable: true,
      required: [],
      properties: {
        custom: mapOfDealsSchemaV1,
        dar: mapOfDealsSchemaV1,
        kras: mapOfDealsSchemaV1,
        local: mapOfDealsSchemaV1,
        stage: mapOfDealsSchemaV1,
      },
    },
    hosts: {
      description:
        "Info about directly deployed workers that is stored by environment that you deployed to",
      type: "object",
      additionalProperties: false,
      nullable: true,
      required: [],
      properties: {
        custom: mapOfHostsSchemaV1,
        dar: mapOfHostsSchemaV1,
        kras: mapOfHostsSchemaV1,
        local: mapOfHostsSchemaV1,
        stage: mapOfHostsSchemaV1,
      },
    },
  },
};

type DealV2 = WorkerInfo & {
  dealId: string;
  dealIdOriginal: string;
  chainNetworkId: number;
  matched?: boolean;
};

type DealsV2 = Partial<Record<FluenceEnv, Record<string, DealV2>>>;
type HostsV2 = Partial<Record<FluenceEnv, Record<string, HostV1>>>;

type ConfigV2 = {
  version: 2;
  deals?: DealsV2;
  hosts?: HostsV2;
};

const dealSchemaV2 = {
  ...workerInfoSchema,
  description:
    "Contains data related to your deployment, including, most importantly, deal id, that can be used to resolve workers in aqua",
  properties: {
    ...workerInfoSchema.properties,
    dealId: {
      type: "string",
      description:
        "Lowercased version of dealIdOriginal without 0x prefix. Currently unused. Was previously used to resolve workers in aqua",
    },
    dealIdOriginal: {
      type: "string",
      description:
        "Blockchain transaction id that you get when deploy workers. Can be used in aqua to get worker and host ids. Check out example in the aqua generated in the default template",
    },
    chainNetwork: {
      type: "string",
      enum: CHAIN_ENV_OLD,
      description:
        "DEPRECATED. Blockchain network name that was used when deploying workers",
      nullable: true,
    },
    chainNetworkId: {
      type: "integer",
      description: "Blockchain network id that was used when deploying workers",
    },
    matched: {
      type: "boolean",
      description: "Is deal matched",
      nullable: true,
    },
  },
  required: [
    ...workerInfoSchema.required,
    "dealId",
    "dealIdOriginal",
    "chainNetworkId",
  ],
} as const satisfies JSONSchemaType<DealV2>;

const mapOfDealsSchemaV2 = {
  type: "object",
  description: "A map of created deals",
  additionalProperties: dealSchemaV2,
  properties: {
    Worker_deployed_using_deals: dealSchemaV2,
  },
  required: [],
  nullable: true,
} as const satisfies JSONSchemaType<Record<string, DealV2>>;

const configSchemaV2 = {
  type: "object",
  additionalProperties: false,
  properties: {
    version: { type: "integer", const: 2, description: "Config version" },
    deals: {
      type: "object",
      description:
        "Info about deals created when deploying workers that is stored by environment that you deployed to",
      additionalProperties: false,
      nullable: true,
      properties: {
        testnet: mapOfDealsSchemaV2,
        custom: mapOfDealsSchemaV2,
        mainnet: mapOfDealsSchemaV2,
        local: mapOfDealsSchemaV2,
        stage: mapOfDealsSchemaV2,
      },
    },
    hosts: {
      description:
        "Info about directly deployed workers that is stored by environment that you deployed to",
      type: "object",
      additionalProperties: false,
      nullable: true,
      properties: {
        testnet: mapOfHostsSchemaV1,
        custom: mapOfHostsSchemaV1,
        mainnet: mapOfHostsSchemaV1,
        local: mapOfHostsSchemaV1,
        stage: mapOfHostsSchemaV1,
      },
    },
  },
  required: ["version"],
} as const satisfies JSONSchemaType<ConfigV2>;

const latestSchema: JSONSchemaType<ConfigV2> = {
  $id: `${TOP_LEVEL_SCHEMA_ID}/${WORKERS_CONFIG_FULL_FILE_NAME}`,
  title: WORKERS_CONFIG_FULL_FILE_NAME,
  description: `A result of app deployment. This file is created automatically after successful deployment using \`${CLI_NAME} workers deploy\` command`,
  ...configSchemaV2,
};

const validateConfigSchemaV0 = ajv.compile(configSchemaV0);
const validateConfigSchemaV1 = ajv.compile(configSchemaV1);

export type Deal = DealV2;
export type Host = HostV1;
export type Deals = DealsV2;
export type Hosts = HostsV2;

const migrations: Migrations<Config> = [
  async (config: Config): Promise<ConfigV1> => {
    if (!validateConfigSchemaV0(config)) {
      throw new Error(
        `Migration error. Errors: ${await validationErrorToString(
          validateConfigSchemaV0.errors,
        )}`,
      );
    }

    const configPath = join(getFluenceDir(), WORKERS_CONFIG_FULL_FILE_NAME);

    const deals: DealsV1 = {};

    for (const [workerName, deal] of Object.entries(config.deals ?? {})) {
      const env = await fluenceEnvOldPrompt(
        `Select the environment that you used for deploying worker ${workerName} with dealId: ${deal.dealId} at ${configPath}`,
      );

      let dealsForEnv = deals[env];

      if (dealsForEnv === undefined) {
        dealsForEnv = {};
        deals[deal.chainNetwork ?? "dar"] = dealsForEnv;
      }

      dealsForEnv[workerName] = deal;
    }

    const hosts: HostsV1 = {};

    for (const [workerName, host] of Object.entries(config.hosts ?? {})) {
      const env = await fluenceEnvOldPrompt(
        `Select the environment that you used for deploying worker ${workerName} with dummyDealId: ${host.dummyDealId} at ${configPath}`,
        "custom",
      );

      let hostsForEnv = hosts[env];

      if (hostsForEnv === undefined) {
        hostsForEnv = {};
        hosts[env] = hostsForEnv;
      }

      hostsForEnv[workerName] = host;
    }

    return {
      version: 1,
      ...(isEmpty(deals) ? {} : { deals }),
      ...(isEmpty(hosts) ? {} : { hosts }),
    };
  },
  async (config: Config): Promise<ConfigV2> => {
    if (!validateConfigSchemaV1(config)) {
      throw new Error(
        `Migration error. Errors: ${await validationErrorToString(
          validateConfigSchemaV0.errors,
        )}`,
      );
    }

    const newConfig: ConfigV2 = { version: 2 };

    for (const [env, configPerEnv] of Object.entries(config.deals ?? {})) {
      if (!isChainEnvOld(env)) {
        throw new Error(
          `Unreachable. Migration error. Unknown env ${env} in ${WORKERS_CONFIG_FULL_FILE_NAME}`,
        );
      }

      if (newConfig.deals === undefined) {
        newConfig.deals = {};
      }

      newConfig.deals[chainEnvOldToNew(env)] = configPerEnv;
    }

    for (const [env, configPerEnv] of Object.entries(config.hosts ?? {})) {
      if (!isChainEnvOld(env)) {
        throw new Error(
          `Unreachable. Migration error. Unknown env ${env} in ${WORKERS_CONFIG_FULL_FILE_NAME}`,
        );
      }

      if (newConfig.hosts === undefined) {
        newConfig.hosts = {};
      }

      newConfig.hosts[chainEnvOldToNew(env)] = configPerEnv;
    }

    return newConfig;
  },
];

type Config = ConfigV0 | ConfigV1 | ConfigV2;
type LatestConfig = ConfigV2;
export type WorkersConfig = InitializedConfig<LatestConfig>;
export type WorkersConfigReadonly = InitializedReadonlyConfig<LatestConfig>;

const initConfigOptions: InitConfigOptions<Config, LatestConfig> = {
  allSchemas: [configSchemaV0, configSchemaV1, latestSchema],
  latestSchema,
  migrations,
  name: WORKERS_CONFIG_FILE_NAME,
  getConfigOrConfigDirPath: getFluenceDir,
};

const getDefault: GetDefaultConfig = () => {
  return `# A result of app deployment.
# This file is updated automatically after successful deployment using \`fluence workers deploy\` command

# config version
version: 0

# deals:
# # A map of created deals
#   ${DEFAULT_PUBLIC_FLUENCE_ENV}:
#     ${DEFAULT_DEPLOYMENT_NAME}:
#       # worker CID
#       definition: bafkreigvy3k4racm6i6vvavtr5mdkllmfi2lfkmdk72gnzwk7zdnhajw4y
#       # ISO timestamp of the time when the worker was deployed
#       timestamp: 2023-07-07T11:23:52.353Z
#       # deal ID used in aqua to resolve workers
#       dealId: 799c4beb18ae084d57a90582c2cb8bb19098139e
#       # original deal ID that you get after signing the contract
#       dealIdOriginal: "0x799C4BEB18Ae084D57a90582c2Cb8Bb19098139E"
#       # network ID that was used when deploying worker
#       chainNetworkId: 1313161555

# hosts:
# # A map of directly deployed workers
#   ${FLUENCE_ENVS[0]}:
#     ${DEFAULT_WORKER_NAME}:
#       # worker CID
#       definition: bafkreicoctafgctpxf7jk4nynpnma4wdxpcecjtspsjmuidmag6enctnqa
#       # worker installation spells
#       # host_id and worker_id can be used to access the worker
#       installation_spells:
#         - host_id: 12D3KooWBM3SdXWqGaawQDGQ6JprtwswEg3FWGvGhmgmMez1vRbR
#           spell_id: 9dbe4003-1232-4a20-9d52-5651c5cf4c5c
#           worker_id: 12D3KooWLBQAdDFXz9vWnmgs6MyMfo25bhUTUEiLPsG94ppYq35w
#       # ISO timestamp of the time when the worker was deployed
#       timestamp: 2023-07-07T11:39:57.610Z
#       # relay that was used when connecting to the network
#       relayId: 12D3KooWPisGn7JhooWhggndz25WM7vQ2JmA121EV8jUDQ5xMovJ
`;
};

export const initNewWorkersConfig = getConfigInitFunction(
  initConfigOptions,
  getDefault,
);

export const initNewWorkersConfigReadonly = getReadonlyConfigInitFunction(
  initConfigOptions,
  getDefault,
);

export const workersSchema: JSONSchemaType<LatestConfig> = latestSchema;
