/**
 * Copyright 2023 Fluence Labs Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { join } from "path";

import oclifColor from "@oclif/color";
const color = oclifColor.default;
import type {
  ArgOutput,
  FlagOutput,
  ParserOutput,
} from "@oclif/core/lib/interfaces/parser.js";
import platform from "platform";
import semver from "semver";

import {
  commandObj,
  isInteractive,
  setCommandObjAndIsInteractive,
  type CommandObj,
} from "./commandObj.js";
import { setUserConfig, userConfig } from "./configs/globalConfigs.js";
import {
  type FluenceConfig,
  initFluenceConfig,
} from "./configs/project/fluence.js";
import {
  CHECK_FOR_UPDATES_DISABLED,
  initNewUserConfig,
  initUserConfig,
  type UserConfig,
} from "./configs/user/config.js";
import {
  NODE_JS_MAJOR_VERSION,
  CHECK_FOR_UPDATES_INTERVAL,
  SEPARATOR,
  CLI_NAME_FULL,
  type NO_INPUT_FLAG_NAME,
  CLI_NAME,
  PACKAGE_NAME,
  GLOBAL_CONFIG_FULL_FILE_NAME,
} from "./const.js";
import { haltCountly, initCountly, logErrorToCountly } from "./countly.js";
import "./setupEnvironment.js";
import { ensureFluenceProject } from "./helpers/ensureFluenceProject.js";
import { getIsInteractive } from "./helpers/getIsInteractive.js";
import { stringifyUnknown } from "./helpers/jsonStringify.js";
import { getLatestVersionOfNPMDependency } from "./npm.js";
import {
  ensureUserFluenceDir,
  projectRootDir,
  recursivelyFindProjectRootDir,
  setProjectRootDir,
} from "./paths.js";
import { confirm, list } from "./prompt.js";

const NO_DOCS_IN_CONFIGS =
  "Only include a comment with a link to the online docs";

const DOCS_IN_CONFIGS = "Include commented-out examples and docs";

const DOCS_IN_CONFIGS_OPTIONS = [NO_DOCS_IN_CONFIGS, DOCS_IN_CONFIGS] as const;

const promptUserAboutDocsInConfigs = async (): Promise<boolean> => {
  if (!isInteractive) {
    return false;
  }

  const docsInConfigsOption = await list({
    message:
      "Select what comments you want to see in the configs generated by the CLI",
    oneChoiceMessage: () => {
      return commandObj.error("Unreachable");
    },
    onNoChoices: () => {
      return commandObj.error("Unreachable");
    },
    options: [...DOCS_IN_CONFIGS_OPTIONS],
  });

  commandObj.logToStderr(
    `If you change your mind later, modify "docsInConfigs" property in ${join(
      await ensureUserFluenceDir(),
      GLOBAL_CONFIG_FULL_FILE_NAME,
    )}`,
  );

  return docsInConfigsOption === DOCS_IN_CONFIGS;
};

const ensureUserConfig = async (): Promise<void> => {
  const maybeUserConfig = await initUserConfig();

  let userConfig: UserConfig;

  const isGeneratingNewUserConfig = maybeUserConfig === null;

  if (isGeneratingNewUserConfig) {
    const docsInConfigs = await promptUserAboutDocsInConfigs();
    userConfig = await initNewUserConfig(docsInConfigs);
  } else {
    userConfig = maybeUserConfig;
  }

  // "docsInConfigs" property is optional. If it's missing - prompt the user and set it
  if (userConfig.docsInConfigs === undefined) {
    userConfig.docsInConfigs = await promptUserAboutDocsInConfigs();
    await userConfig.$commit();
  }

  if (
    isGeneratingNewUserConfig &&
    isInteractive &&
    (await confirm({
      message: `Help me improve ${CLI_NAME_FULL} by sending anonymous usage data. I don't collect IDs, names, or other personal data.\n${color.gray(
        "Metrics will help the developers know which features are useful so they can prioritize what to work on next. Fluence Labs hosts a Countly instance to record anonymous usage data.",
      )}\nOK?`,
    }))
  ) {
    userConfig.countlyConsent = true;
    await userConfig.$commit();

    commandObj.logToStderr(
      `If you change your mind later, modify "countlyConsent" property in ${userConfig.$getPath()}`,
    );
  }

  setUserConfig(userConfig);
};

type CommonReturn<A extends ArgOutput, F extends FlagOutput> = {
  args: A;
  flags: F;
};

type ParserOutputWithNoInputFlag<
  F extends FlagOutput,
  F2 extends FlagOutput,
  A extends ArgOutput,
> = ParserOutput<F, F2, A> & {
  flags: {
    [NO_INPUT_FLAG_NAME]: boolean;
  };
};

export async function initCli<
  F extends FlagOutput,
  F2 extends FlagOutput,
  A extends ArgOutput,
>(
  commandObj: CommandObj,
  parserOutput: ParserOutputWithNoInputFlag<F, F2, A>,
  requiresFluenceProject?: false,
): Promise<CommonReturn<A, F> & { maybeFluenceConfig: FluenceConfig | null }>;
export async function initCli<
  F extends FlagOutput,
  F2 extends FlagOutput,
  A extends ArgOutput,
>(
  commandObj: CommandObj,
  parserOutput: ParserOutputWithNoInputFlag<F, F2, A>,
  requiresFluenceProject: true,
): Promise<CommonReturn<A, F> & { fluenceConfig: FluenceConfig }>;

export async function initCli<
  F extends FlagOutput,
  F2 extends FlagOutput,
  A extends ArgOutput,
>(
  commandObjFromArgs: CommandObj,
  { args, flags }: ParserOutputWithNoInputFlag<F, F2, A>,
  requiresFluenceProject = false,
): Promise<
  CommonReturn<A, F> & {
    fluenceConfig?: FluenceConfig | null;
    maybeFluenceConfig?: FluenceConfig | null;
  }
> {
  setProjectRootDir(await recursivelyFindProjectRootDir(projectRootDir));
  setCommandObjAndIsInteractive(commandObjFromArgs, getIsInteractive(flags));

  if (platform.version === undefined) {
    return commandObj.error("Unknown platform");
  }

  const majorVersion = Number(platform.version.split(".")[0]);

  if (majorVersion !== NODE_JS_MAJOR_VERSION) {
    return commandObj.error(
      `${CLI_NAME_FULL} requires Node.js version "${NODE_JS_MAJOR_VERSION}.x.x"; Detected ${platform.version}.\nYou can use https://nvm.sh utility to set Node.js version: "nvm install ${NODE_JS_MAJOR_VERSION} && nvm use ${NODE_JS_MAJOR_VERSION} && nvm alias default ${NODE_JS_MAJOR_VERSION}"`,
    );
  }

  // just doing these operations in parallel cause they are independent
  // only `maybeFluenceConfig` config is destructured cause `ensureUserConfig`
  // function sets a global singleton that is available everywhere
  await ensureUserConfig();
  const maybeFluenceConfig = await initFluenceConfig();

  await initCountly({ maybeFluenceConfig });
  await ensureCorrectCliVersion(maybeFluenceConfig?.cliVersion);

  return {
    args,
    flags,
    ...(requiresFluenceProject
      ? {
          fluenceConfig:
            maybeFluenceConfig === null
              ? await ensureFluenceProject()
              : maybeFluenceConfig,
        }
      : { maybeFluenceConfig }),
  };
}

const isCheckForUpdatesRequired = async () => {
  const { lastCheckForUpdates } = userConfig;

  if (lastCheckForUpdates === CHECK_FOR_UPDATES_DISABLED) {
    return false;
  }

  const now = new Date();
  const lastCheckForUpdatesDate = new Date(lastCheckForUpdates ?? 0);
  const lastCheckForUpdatesMilliseconds = lastCheckForUpdatesDate.getTime();

  if (
    lastCheckForUpdates === undefined ||
    Number.isNaN(lastCheckForUpdatesMilliseconds) ||
    now.getTime() - lastCheckForUpdatesMilliseconds > CHECK_FOR_UPDATES_INTERVAL
  ) {
    userConfig.lastCheckForUpdates = now.toISOString();
    await userConfig.$commit();
    return true;
  }

  return false;
};

const ensureCorrectCliVersion = async (
  maybeCliVersion: string | undefined,
): Promise<void> => {
  const currentVersion = commandObj.config.version;

  if (
    typeof maybeCliVersion === "string" &&
    maybeCliVersion !== currentVersion
  ) {
    const cliVersion = maybeCliVersion;
    return commandObj.error(
      `Current ${CLI_NAME_FULL} versions is ${color.yellow(
        currentVersion,
      )}, but this project is compatible only with ${CLI_NAME_FULL} version ${color.yellow(
        cliVersion,
      )}\n\nPlease install it with:\n\n${color.yellow(
        `npm i -g ${PACKAGE_NAME}@${cliVersion}`,
      )}\n\nAfter that, run:\n\n${color.yellow(
        `${CLI_NAME} dep v`,
      )}\n\nto find out which version of rust-peer you need to use to make sure you are running ${CLI_NAME_FULL} against the compatible version of rust-peer\n\n`,
    );
  }

  if (!isInteractive || !(await isCheckForUpdatesRequired())) {
    return;
  }

  try {
    const [stableVersion, unstableVersion] = await Promise.all([
      getLatestVersionOfNPMDependency(`${PACKAGE_NAME}`),
      getLatestVersionOfNPMDependency(`${PACKAGE_NAME}@unstable`),
    ]);

    const isOlderThanStable = semver.lt(currentVersion, stableVersion);
    const isStable = semver.eq(currentVersion, stableVersion);
    const isOlderThenUnstable = semver.lt(currentVersion, unstableVersion);
    const hasUpdates = isOlderThanStable || isOlderThenUnstable;

    if (isStable || !hasUpdates) {
      return;
    }

    const version = isOlderThanStable ? stableVersion : unstableVersion;

    commandObj.logToStderr(
      `${SEPARATOR}New ${color.yellow(
        isOlderThanStable ? "stable" : "unstable",
      )} version ${color.yellow(
        version,
      )} of ${CLI_NAME_FULL} is available\n\nYou can install it with:\n\n${color.yellow(
        `npm i -g ${PACKAGE_NAME}@${version}`,
      )}${SEPARATOR}`,
    );

    if (
      await confirm({
        message:
          "Do you want me to continue checking for updates once per day?",
      })
    ) {
      userConfig.lastCheckForUpdates = CHECK_FOR_UPDATES_DISABLED;
      await userConfig.$commit();

      commandObj.logToStderr(
        `\nUpdates checking is now disabled. You can enable it again by removing 'lastCheckForUpdates' property from ${userConfig.$getPath()}\n`,
      );
    }
  } catch (e) {
    logErrorToCountly(`npm version check failed: ${stringifyUnknown(e)}`);
  }
};

export const exitCli = async (): Promise<never> => {
  await haltCountly();

  // Countly doesn't let process to finish
  // So there is a need to do it explicitly
  // eslint-disable-next-line no-process-exit
  process.exit(0);
};
